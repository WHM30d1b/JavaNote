## 面试题

#### 1. 内核锁

Linux 同步机制的完善依赖内核锁的发展，推进单处理器到对称多处理器的过度

主要包括：

- 自旋锁：只能被一个线程持有，其他线程请求使用会进入循环等待，直到锁重新可用
- 睡眠锁：任务试图获得已被持有的信号量，会被信号量推入等待队列并睡眠，信号量被释放时，唤醒等待队列的任务

同步机制：原子操作，信号量，自旋锁，大内核锁，读写锁，大读者锁，RCU Read Copy Update，顺序锁



#### 2. 用户模式和内核模式

- 内核运行在**受信任**的内核模式，其他用户进程都运行在**受限制**的用户模式

- 内核模式的代码可以无**限制**地访问所有处理器指令集，以及全部内存和 I/O 空间。用户模式的进程要享有此特权必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。

- 用户模式的代码允许发生**缺页**，内核模式的代码不允许。
- 2.4 以前的内核中，仅用户模式的进程可以被上下文切换出局，由其他进程**抢占**。内核模式代码可以一直独占 CPU，除非自愿放弃或发生中断或异常。2.6 内核引入了内核抢占。



模块运行在内核空间，不能使用链接库函数

应用程序运行在用户空间



#### 3. 申请大内存

系统运行时间越长，越难申请到大内存，在系统启动阶段申请到大内存的几率较高

内存申请代码只能在内核中使用，申请到的内存处于系统可见内存之外，且需要自己实现内存管理

只有在强制要求分配内存的场合才需要采取这种预留内存空间的方法



#### 4. 用户进程间的通信方式

- Pipe：管道，一个进程和另一个有共同祖先的进程之间进行通信。
- Named Pipe：命名管道，无亲缘关系进程通信
- Signal：信号，进程与自己和其他进程通信
- Message Queue：消息队列
- 共享内存：多个进程访问同一块内存空间
- Semaphore：信号量，进程同步
- Socket：套接字，不同机器之间的进程通信



#### 5. 文件类型

- 执行文件
- 普通文件
- 目录文件
- 链接文件
- 设备文件
- 管道文件



#### 6. 创建进程的系统调用

- clone()
- fork()
- vfork()

系统调用服务例程：

- sys_clone
- sys_fork
- sys_vfork



#### 7. schedule() 进程切换方式

- 系统调用 do_fork()
- 定时中断 do_timer()
- 唤醒进程 wake_up_process
- 改变进程的调度策略 setscheduler()
- 系统调用礼让 sys_sched_yield()



#### 8. Linux 进程调度

Liunx 调度程序根据进程的动态优先级来调度进程的，但动态优先级是根据静态优先级算法计算出来的，两者是相关联的值。

进程调度核心数据结构：struct runqueue



#### 9. 加载卸载模块的指令

加载：insmod

卸载：rmmod



#### 10. 浮点数运算由内核还是应用程序完成

应用程序通过数学库的函数完成运算，把结果返回给系统

创建内核时勾选 math-emu 使用内核完成运算，但是其他应用程序同样使用 math-emu，效率降低



#### 11. TLB 中的缓存内容

页表缓存，线性地址第一次转换成物理地址的时候，将线性地址和物理地址的对应放到 TLB 中，再次访问时加快访问速度



#### 12. 系统调用如何实现

软件中断实现：

- 用户程序为系统调用设置参数，其中一个编号是系统调用编号
- 程序执行系统调用指令
- 指令会导致一个异常，产生一个事件导致处理器跳转到内核态并跳转到一个新的地址，即异常处理程序
- 异常处理就是系统调用程序



#### 13. 软中断和工作队列

中断处理

- 软中断：可延迟函数的总称，不能睡眠，不能阻塞，处于中断上下文，不能进程切换，不能被自己打断，只能被硬件中断打断，可以并发的运行在多个 CPU 上。
- 工作队列：函数处在进程上下文中，可以睡眠，可以被阻塞，能够在不同的进程间切换。



可延迟函数和工作队列都不能访问用户的进程空间：

- 可延时函数在执行时不可能有任何正在运行的进程
- 工作队列的函数由内核进程执行，不能访问用户空间地址









