## 面试题

#### 1. 简述 Redis

Remote Dictionary Server 远程字典服务，本质上是 Key - Value 类型的内存数据库。

数据加载到内存操作，定期通过异步将数据 flush 到硬盘保存。

**速度最快**的非关系型数据库，秒均 10 万次读写

最大的优势在于**多种数据结构**，单个 Value 限制 1 GB，用 List 做 FIFO 双向链表，实现高性能消息队列

对存入的键值对可以设置**失效时间**

最大的限制来源于物理内存大小，无法做海量数据的读写，适合小数据量的**高性能运算**场景



#### 2. Redis 相较于 memcached

- memcached 值的类型只有简单字符串，可以缓存图片和视频，Redis 支持更丰富的数据类型
- Redis 速度快，mc 多线程模型引入了缓存一致性和锁，带来了性能损耗
- Redis 可以通过 RDB 和 AOF 持久化数据，通过主从配置进行数据备份，更好的灾备机制
- Redis 支持在服务器端做分布式，Memcached 使用 Magent 在客户端进行一致性 Hash 做分布式
- Memcached 最大键长 250 个字符 ( slab ) ，Redis 为 512K
- Redis 单线程保证按序提交，Memcached 使用 CAS 算法保证并发一致性
- Redis 单核，Memcached 多核，在存储小数据上用 Redis，大数据用 Memcached
- 内存管理：
  - Memcached 使用 Slab Allocation。预先分配一系列大小固定的组，然后根据数据大小选择最合适的块存储，避免了内存碎片。默认情况下，slab 的最大值为前一个的 1.25 倍
  - Redis 定义一个数组来记录所有的内存分配情况，Redis 采用的是包装的 malloc / free，简单很多。malloc 首先以链表的方式搜索已管理的内存中可用的空间分配， 导致内存碎片比较多



Redis 和 memcached 使用场景

Redis：

- **复杂数据结构**，value 的数据是 Hash，列表 List，集合 Set，有序集合 Zset
- **数据的持久化**，只读和数据一致性要求不高的场景
- **高可用**，redis 支持集群主从复制，读写分离
- 存储的内容比较大 1GB，memcache 存储的 value 最大为 1MB

memcache：

- 纯 KV 数据类型，数据量非常大的业务用 memcache

- memcache 的内存分配采用的是预分配内存池的管理方式，能够省去内存分配的时间，redis 是临时申请空间，可能导致碎片化
- memcache 将所有的数据存储在物理内存，redis 有自己的 vm 机制，能够存储比物理内存更多的数据，当数据超量时，引发 swap，把冷数据刷新到磁盘上，数据量大时，memcache 更快
- 网络模型，memcache 使用非阻塞的 IO 复用模型，redis 也是使用非阻塞的 IO 复用模型，但是 redis 还提供了一些非 KV 存储之外的排序，聚合功能，复杂的 CPU 计算，会阻塞整个 IO 调度，从这点上由于 redis 提供的功能较多，memcache 更快些
- 线程模型，memcache 使用多线程，主线程监听，worker 子线程接受请求，执行读写，这个过程可能存在锁冲突。redis 使用的单线程，虽然无锁冲突，但是难以利用多核的特性提升吞吐量



#### 3. 淘汰策略

当内存到达上限，客户端尝试执行使用更多内存的命令时，进行淘汰，保证数据的热点属性

- noeviction：报错
- allkeys-lru：回收所有键集合中最少使用的键
- volatile-lru：回收过期键集合中最少使用的键
- allkeys-random：随机回收所有键集合中的键
- volatile-random：随机回收过期键集合中的键
- volatile-ttl：回收过期键集合中存活时间较短的键



#### 4. 集群方案

主从复制：使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用

- twemproxy：访问反向代理
- codis：支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点
- redis cluster 3.0：支持节点设置从节点，分布式算法不是一致性 hash，而是 hash 槽
- 业务层代码实现：自己实现算法，包括节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控



哈希槽：Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。



集群不可用情况：

- 访问一个 Master 和 Slave 节点都挂了的槽的时候，会报槽无法获取。
- 当集群 Master 节点个数小于 3 个的时候，或者集群可用节点个数为偶数的时候，基于 fail 的这种选举机制的自动主从切换过程可能会不能正常工作，一个是标记 fail 的过程，一个是选举新的 master 的过程，都有可能异常。



#### 5. Redis 使用场景

- Session Cache：会话缓存持久化
- FPC：全页缓存，优化全页加载速度
- 队列：基于 List 数据结构中的 push 和 pop 方法实现队列
- 排行榜：基于有序集合 Stored Set 实现数字排序
- 发布订阅：自带发布订阅功能



#### 6. Redis 写操作丢失

Redis 不能保证数据的强一致性



#### 7. 管道的作用

旧的请求还未被响应，服务器也能处理新的请求。可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。



#### 8. Redis 事务

相关命令：MULTI、EXEC、DISCARD、WATCH

事务中的所有命令都会序列化按顺序地执行。在执行的过程中，不会被其他客户端发送来的命令请求所打断。

事务是一个原子操作，命令要么全部被执行，要么全部都不执行。



#### 9. 性能优化

- 尽可能使用散列表（hashes），单个用户的所有信息存储到一张散列表里面，通过关键码值直接访问。
- 使用 Hash，list，sorted set，set 等集合类型数据， 通常情况下很多小的 key - value 存放更加紧凑
- Master 尽量不做 RDB 内存快照或 AOF 日志文件持久化工作
- 重要的数据让 Slave 节点开启 AOF 备份数据，每秒同步一次
- Master 和 Slave 在同一局域网，提高链接和主从复制速度
- 压力很大的 Master 上尽量少添加 Slave
- 主从复制使用单向链表优于图



#### 10. 持久化方式 RDB 和 AOF

RDB ( Redis DataBase )：在指定的时间间隔对数据进行快照存储

AOF ( Append Only File )：记录对服务器写的操作，服务器重启的时候重新执行这些命令来恢复原始的数据

通常情况下 AOF 文件保存的数据集比 RDB 文件保存的数据集完整，Redis 重启的时候优先载入 AOF 文件来恢复原始的数据



#### 11. 分布式锁的实现

ZooKeeper：实现简单，开销大，性能差。  

1. 客户端对某个方法加锁时，在 zk 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点 node1
2. 客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 node1 的序号是最小的，就认为这个客户端获得了锁
3. 如果发现 node1 不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待
4. 获取锁后，处理完逻辑，删除自己创建的 node1 即可



数据库：简单，开销大

- 基于数据库表的增删

  - 创建一张锁的表主要包含类的全路径名+方法名，时间戳等字段
  - 需要锁住某个方法时，往该表中插入一条唯一性约束的类的全路径名+方法名的记录
  - 执行完毕之后，delete 该记录

- 基于数据库排他锁

  - 查询语句后面增加 for update，数据库会在查询过程中给数据库表增加排他锁

    当某条记录被加上排他锁之后，其他线程无法获取排他锁并被阻塞

  - 获得排它锁的线程即可获得分布式锁，获得锁之后，可以执行方法的业务逻辑

  - 执行完方法后，释放锁 `connection.commit()`



Redis：

- 方案一：SETNX + EXPIRE

  用 setnx 抢锁，再用 expire 设置过期时间

  问题：抢锁和设置过期时间两个命令一起不具有原子性，可能设置锁后无法释放

  

- 方案二：SETNX + value值是（系统时间+过期时间）

  不用 expire 设置过期时间，把过期时间放到锁的 value 里面，如果其他线程加锁失败，拿出 value 进行校验

  问题：没有保存持有者的唯一标识，可能被别的客户端释放/解锁

  

- 方案三：使用Lua脚本 (包含SETNX + EXPIRE两条指令)

  使 setnx 和 expire 具有原子性

  

- 方案四：SET的扩展命令（SET EX PX NX）

  set 指令的扩展参数具有原子性

  - NX：key 不存在的时候，才能set成功，保证只有第一个客户端请求才能获得锁
  - EX seconds：设定 key 的过期时间，时间单位是秒
  - PX milliseconds：设定 key 的过期时间，单位为毫秒
  - XX：仅当key存在时设置值

  问题：任务未执行完，锁就被释放了；没有锁持有者的唯一标识，会被其他线程误删

  

- 方案五：SET EX PX NX  + 校验唯一随机值,再释放锁

  给 value 设置一个标记当前线程唯一的随机数，在删除的时候进行校验

  问题：任务未执行完，锁过期自动释放

  

- 方案六: 开源框架~Redisson

  开启定时守护线程（看门狗），每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。

  

- 方案七：多机实现的分布式锁Redlock

  - 按顺序向 5 个 master 节点请求加锁
  - 根据设置的超时时间来判断，是不是要跳过该master节点
  - 如果大于等于 3 个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功
  - 如果获取锁失败，解锁



#### 12. 缓存穿透，击穿，雪崩

穿透：查询不存在的数据，存储层查不到数据无法写入缓存，导致不存在的数据每次都要到 DB 去查询，导致 DB 挂掉。

解决方案：

- 查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短
- 布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，不存在的数据会被 bitmap 拦截掉，从而避免对 DB 的查询



击穿：一个 key 的缓存过期，恰好有大量查询这个 key 的并发请求，直接访问压垮 DB。

解决方案：

- 使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的方法。
- 永远不过期：物理不过期，但逻辑过期，后台异步线程去刷新。



雪崩：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB，DB 瞬时压力过重雪崩。

解决方案：将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值， 比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。



#### 13. 缓存与数据库不一致问题

主库和从库对同一数据更新不一致

处理思路：

- 从库发生数据更新之后，向缓存发出删除指令，淘汰这段时间写入的旧数据
- 直接忽略这个数据不一致
- 强制读主库
- 选择性读主库，添加一个缓存记录必须读主库的数据，设置缓存失效的时间为主从库同步的时间，如果缓存当中有这个数据，直接读取主库，如果缓存当中没有这个主键，就到对应的从库中读取



#### 14. 为什么要做 Redis 分区

如果没有分区，只能使用一台机器的内存，分区可以让 Redis 使用所有机器的内存

分区通过简单地增加计算机，使 Redis 的计算能力得到成倍提升，网络带宽也随着计算机和网卡的增加而成倍增长



#### 15. Memcached

- 完全基于内存缓存，无持久性存储的设计，重启服务器，内存数据丢失
- 节点之间相互独立
- C / S 模式架构，C 语言编写，总共 2000 行代码
- 异步 I/O 模型，使用 libevent 作为事件通知机制
- 被缓存的数据以 key / value 键值对形式存在的
- 内存容量到达阈值，自动使用 LRU 算法删除过期的缓存数据
- 对存储的数据设置过期时间，过期的数据自动被清除。服务本身不监控，在访问时查看 key 的时间戳，判断是否过期
- memcached 对设定的内存进行分块，再把块分组，然后提供服务



#### 16. 实现 Session 的共享存储

- 粘性 Session：Ngnix 将同一用户的所有请求转发至同一台服务器上，将用户与服务器绑定
- 服务器 Session 同步：Session 创建或者修改时，广播给所有集群中的服务器，使所有的服务器上的 Session 相同
- Session 共享：使用 redis / memcached 缓存 Session
- Session 持久化：将 Session 存储至数据库中





#### 999. 杂谈

- Redis 集群之间异步复制

- 集群最大节点数 16384

- 无法选择数据库，默认在 0 数据库

- 设置过期时间：EXPIRE 和 PERSIST 命令

- 一个字符串值存储的最大容量：512 MB

- Java 客户端：

  - 官方推荐 Redisson：高级的分布式协调 Redis 客服端，帮助用户在分布式环境中轻松实现一些 Java 的对象

    功能简单，不支持字符串，不支持事务、排序、管道、分区等 Redis 特性

    宗旨是促使分离，关注于处理业务逻辑

  - Jedis：Java 实现的客户端，提供全面的 Redis 命令支持

  - lettuce

- Redis 分布式最好一开始就做。因为轻量，单个 Redis 实例只占用 1M 内存，一次启动 32 个或 64 个，以后需要扩容的时候只需要将实例迁移到其他机器，而不需要考虑分区问题。

- 一致性哈希算法：对于分布式存储，不同机器上存储不同对象的数据，使用哈希函数建立从数据到服务器之间的映射关系。

  保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间，不会造成全局的网络问题。

- Redis 单线程，发挥多核计算机 CPU 的利用率，可以部署多个 Redis 实例当作不同服务























